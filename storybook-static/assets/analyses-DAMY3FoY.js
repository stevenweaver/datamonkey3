import{d as p,w as S}from"./index-BzKHlfNo.js";const b=!0,v="fasta-validation-db",I=1,g="files",A="analyses";async function f(){return new Promise((i,a)=>{const s=indexedDB.open(v,I);s.onerror=r=>{console.error("IndexedDB error:",r.target.error),a(r.target.error)},s.onsuccess=r=>{const e=r.target.result;i(e)},s.onupgradeneeded=r=>{const e=r.target.result;if(!e.objectStoreNames.contains(g)){const t=e.createObjectStore(g,{keyPath:"id"});t.createIndex("filename","filename",{unique:!1}),t.createIndex("createdAt","createdAt",{unique:!1})}if(!e.objectStoreNames.contains(A)){const t=e.createObjectStore(A,{keyPath:"id"});t.createIndex("fileId","fileId",{unique:!1}),t.createIndex("method","method",{unique:!1}),t.createIndex("createdAt","createdAt",{unique:!1})}}})}const x={async saveFile(i,a={}){try{const s=await f(),r=await this.findFileByName(i.name);if(r&&!a.forceNew)return this.updateFile(r.id,{...r,type:i.type,size:i.size,content:await i.arrayBuffer(),updatedAt:new Date().getTime(),...a});const e=crypto.randomUUID(),t=await i.arrayBuffer();return new Promise((n,o)=>{const c=s.transaction([g],"readwrite").objectStore(g),y={id:e,filename:i.name,type:i.type,size:i.size,content:t,createdAt:new Date().getTime(),...a},d=c.add(y);d.onsuccess=()=>{n(e)},d.onerror=u=>{console.error("Error saving file:",u.target.error),o(u.target.error)}})}catch(s){throw console.error("Error in saveFile:",s),s}},async getFile(i){try{const a=await f();return new Promise((s,r)=>{const n=a.transaction([g],"readonly").objectStore(g).get(i);n.onsuccess=o=>{o.target.result?s(o.target.result):r(new Error("File not found"))},n.onerror=o=>{console.error("Error retrieving file:",o.target.error),r(o.target.error)}})}catch(a){throw console.error("Error in getFile:",a),a}},async getAllFiles(){try{const i=await f();return new Promise((a,s)=>{const t=i.transaction([g],"readonly").objectStore(g).getAll();t.onsuccess=n=>{const o=n.target.result.map(l=>{const{content:c,...y}=l;return y});a(o)},t.onerror=n=>{console.error("Error retrieving files:",n.target.error),s(n.target.error)}})}catch(i){throw console.error("Error in getAllFiles:",i),i}},async deleteFile(i){try{const a=await f();return new Promise((s,r)=>{const n=a.transaction([g],"readwrite").objectStore(g).delete(i);n.onsuccess=()=>{s(!0)},n.onerror=o=>{console.error("Error deleting file:",o.target.error),r(o.target.error)}})}catch(a){throw console.error("Error in deleteFile:",a),a}},async updateFile(i,a){try{const s=await f();return new Promise((r,e)=>{const o=s.transaction([g],"readwrite").objectStore(g).put(a);o.onsuccess=()=>{r(!0)},o.onerror=l=>{console.error("Error updating file:",l.target.error),e(l.target.error)}})}catch(s){throw console.error("Error in updateFile:",s),s}},async findFileByName(i){try{const a=await f();return new Promise((s,r)=>{const o=a.transaction([g],"readonly").objectStore(g).index("filename").getAll(i);o.onsuccess=l=>{const c=l.target.result;if(c&&c.length>0){const y=c.sort((d,u)=>u.createdAt-d.createdAt);s(y[0])}else s(null)},o.onerror=l=>{console.error("Error finding file by name:",l.target.error),r(l.target.error)}})}catch(a){throw console.error("Error in findFileByName:",a),a}},async fileRecordToFile(i){try{const{content:a,filename:s,type:r}=i;return new File([a],s,{type:r})}catch(a){throw console.error("Error converting file record:",a),a}}},w={async saveAnalysis(i){try{const a=await f(),s=i.id||crypto.randomUUID();return new Promise((r,e)=>{const n=a.transaction([A],"readwrite").objectStore(A),o={...i,id:s,createdAt:i.createdAt||new Date().getTime(),updatedAt:new Date().getTime()},l=n.put(o);l.onsuccess=()=>{r(s)},l.onerror=c=>{console.error("Error saving analysis:",c.target.error),e(c.target.error)}})}catch(a){throw console.error("Error in saveAnalysis:",a),a}},async getAnalysis(i){try{const a=await f();return new Promise((s,r)=>{const n=a.transaction([A],"readonly").objectStore(A).get(i);n.onsuccess=o=>{o.target.result?s(o.target.result):r(new Error("Analysis not found"))},n.onerror=o=>{console.error("Error retrieving analysis:",o.target.error),r(o.target.error)}})}catch(a){throw console.error("Error in getAnalysis:",a),a}},async getAllAnalyses(){try{const i=await f();return new Promise((a,s)=>{const t=i.transaction([A],"readonly").objectStore(A).getAll();t.onsuccess=n=>{a(n.target.result)},t.onerror=n=>{console.error("Error retrieving analyses:",n.target.error),s(n.target.error)}})}catch(i){throw console.error("Error in getAllAnalyses:",i),i}},async getAnalysesByFileId(i){try{const a=await f();return new Promise((s,r)=>{const o=a.transaction([A],"readonly").objectStore(A).index("fileId").getAll(i);o.onsuccess=l=>{s(l.target.result)},o.onerror=l=>{console.error("Error retrieving analyses for file:",l.target.error),r(l.target.error)}})}catch(a){throw console.error("Error in getAnalysesByFileId:",a),a}},async deleteAnalysis(i){try{const a=await f();return new Promise((s,r)=>{const n=a.transaction([A],"readwrite").objectStore(A).delete(i);n.onsuccess=()=>{s(!0)},n.onerror=o=>{console.error("Error deleting analysis:",o.target.error),r(o.target.error)}})}catch(a){throw console.error("Error in deleteAnalysis:",a),a}},async clearAllAnalyses(){try{const i=await f();return new Promise((a,s)=>{const t=i.transaction([A],"readwrite").objectStore(A).clear();t.onsuccess=()=>{a(!0)},t.onerror=n=>{console.error("Error clearing all analyses:",n.target.error),s(n.target.error)}})}catch(i){throw console.error("Error in clearAllAnalyses:",i),i}}},F=b;function D(){const{subscribe:i,set:a,update:s}=S({analyses:[],currentAnalysisId:null,isLoading:!1,error:null,activeAnalysis:{id:null,status:null,progress:0,message:"",logs:[]},activeAnalysesList:[]});return{subscribe:i,update:s,async loadAnalyses(){s(r=>({...r,isLoading:!0,error:null}));try{const r=await w.getAllAnalyses();s(e=>({...e,analyses:r,isLoading:!1}))}catch(r){console.error("Error loading analyses:",r),s(e=>({...e,error:r.message,isLoading:!1}))}},async createAnalysis(r,e){s(t=>({...t,isLoading:!0,error:null}));try{const t=crypto.randomUUID(),n={id:t,fileId:r,method:e,status:"pending",createdAt:new Date().getTime()};return await w.saveAnalysis(n),s(o=>({...o,analyses:[...o.analyses,n],currentAnalysisId:t,isLoading:!1})),t}catch(t){throw console.error("Error creating analysis:",t),s(n=>({...n,error:t.message,isLoading:!1})),t}},async getAnalysis(r){s(e=>({...e,isLoading:!0,error:null}));try{const e=await w.getAnalysis(r);return s(t=>{const n=t.analyses.map(o=>o.id===r?e:o);return{...t,analyses:n,isLoading:!1}}),e}catch(e){throw console.error("Error fetching analysis:",e),s(t=>({...t,error:e.message,isLoading:!1})),e}},async updateAnalysis(r,e){s(t=>({...t,isLoading:!0,error:null}));try{const n={...await w.getAnalysis(r),...e,updatedAt:new Date().getTime()};return await w.saveAnalysis(n),s(o=>{const l=o.analyses.map(c=>c.id===r?n:c);return{...o,analyses:l,isLoading:!1}}),n}catch(t){throw console.error("Error updating analysis:",t),s(n=>({...n,error:t.message,isLoading:!1})),t}},async deleteAnalysis(r){s(e=>({...e,isLoading:!0,error:null}));try{await w.deleteAnalysis(r),s(e=>({...e,analyses:e.analyses.filter(t=>t.id!==r),currentAnalysisId:e.currentAnalysisId===r?null:e.currentAnalysisId,isLoading:!1}))}catch(e){throw console.error("Error deleting analysis:",e),s(t=>({...t,error:e.message,isLoading:!1})),e}},async cancelAnalysis(r){try{await this.updateAnalysis(r,{status:"cancelled",completedAt:new Date().getTime()}),s(e=>{const t={...e};return t.activeAnalysis.id===r&&(t.activeAnalysis={id:null,status:null,progress:0,message:"",logs:[]}),t.activeAnalysesList=t.activeAnalysesList.filter(n=>n.id!==r),t})}catch(e){throw console.error("Error cancelling analysis:",e),e}},async loadAnalysesForFile(r){s(e=>({...e,isLoading:!0,error:null}));try{const e=await w.getAnalysesByFileId(r);return s(t=>{const n=t.analyses.filter(o=>o.fileId!==r);return{...t,analyses:[...n,...e],isLoading:!1}}),e}catch(e){throw console.error("Error loading analyses for file:",e),s(t=>({...t,error:e.message,isLoading:!1})),e}},setCurrentAnalysis(r){s(e=>({...e,currentAnalysisId:r}))},clearError(){s(r=>({...r,error:null}))},startAnalysisProgress(r,e="Initializing analysis...",t="",n=""){let o=t,l=n;s(c=>{if(!o||!l){const h=c.analyses.find(L=>L.id===r);h&&(o=o||h.method,l=l||h.fileName)}const y={id:r,status:"initializing",progress:0,message:e,method:o,fileName:l,startTime:new Date().toISOString(),logs:[{time:new Date().toISOString(),message:e,status:"initializing"}]},d={...y},m=[...c.activeAnalysesList.filter(h=>h.id!==r),y];return{...c,activeAnalysis:d,activeAnalysesList:m}})},updateAnalysisProgress(r,e,t){s(n=>{const o=n.activeAnalysis.id;if(!o)return n;const l=[...n.activeAnalysis.logs],c=l[l.length-1];(!c||c.message!==t||c.status!==r)&&l.push({time:new Date().toISOString(),message:t,status:r});const y={...n.activeAnalysis,status:r,progress:Math.min(Math.max(0,e),100),message:t,logs:l},d=n.activeAnalysesList.map(u=>u.id!==o?u:{...u,status:r,progress:Math.min(Math.max(0,e),100),message:t,logs:[...l]});return{...n,activeAnalysis:y,activeAnalysesList:d}})},async completeAnalysisProgress(r=!0,e=r?"Analysis completed.":"Analysis failed."){var l;const t=r?"completed":"error";let n;i(c=>{n=c})();const o=(l=n==null?void 0:n.activeAnalysis)==null?void 0:l.id;if(o&&(s(c=>{const y=[...c.activeAnalysis.logs];y.push({time:new Date().toISOString(),message:e,status:t});const d={...c.activeAnalysis,status:t,progress:r?100:c.activeAnalysis.progress,message:e,logs:y,completedAt:r?new Date().toISOString():void 0},u=c.activeAnalysesList.map(m=>m.id!==o?m:{...m,status:t,progress:r?100:m.progress,message:e,logs:[...y],completedAt:r?new Date().toISOString():void 0});return{...c,activeAnalysis:d,activeAnalysesList:u}}),o)){const c=n.activeAnalysis.logs||[],y=n.activeAnalysis.result||null;try{const d=await w.getAnalysis(o);if(d){const u=y||d.result;await w.saveAnalysis({...d,status:t,logs:c,result:u,completedAt:r?new Date().getTime():void 0}),s(m=>({...m,analyses:m.analyses.map(h=>h.id===o?{...h,status:t,logs:c,result:u,completedAt:r?new Date().getTime():void 0}:h)}))}}catch(d){console.error("Error updating analysis in IndexedDB:",d)}try{F&&fetch(`/api/analyses/${o}`,{method:"PATCH",headers:{"Content-Type":"application/json"},body:JSON.stringify({status:t,logs:c,result:y,completedAt:r?new Date().getTime():void 0})}).then(d=>d.json()).then(d=>{console.log("Server analysis status updated:",d)}).catch(d=>{console.error("Error updating analysis status on server:",d)})}catch(d){console.error("Error updating analysis on server:",d)}}},removeFromActiveAnalyses(r){s(e=>({...e,activeAnalysesList:e.activeAnalysesList.filter(t=>t.id!==r)}))},async clearAllAnalyses(){s(r=>({...r,isLoading:!0,error:null}));try{await w.clearAllAnalyses(),s(r=>({...r,analyses:[],currentAnalysisId:null,activeAnalysis:{id:null,status:null,progress:0,message:"",logs:[]},activeAnalysesList:[],isLoading:!1}))}catch(r){throw console.error("Error clearing all analyses:",r),s(e=>({...e,error:r.message,isLoading:!1})),r}}}}const E=D();p(E,i=>i.currentAnalysisId?i.analyses.find(a=>a.id===i.currentAnalysisId):null);const q=p(E,i=>i.activeAnalysis),j=p(E,i=>i.activeAnalysesList);export{E as a,j as b,q as c,x as f};
