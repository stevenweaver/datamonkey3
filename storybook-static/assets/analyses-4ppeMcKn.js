import{d as f,w as L}from"./index-BJUjmB_L.js";import{a as d}from"./fileInfo-DmhC3Ja7.js";const h=!0,w=h;function S(){const{subscribe:y,set:m,update:a}=L({analyses:[],currentAnalysisId:null,isLoading:!1,error:null,activeAnalysis:{id:null,status:null,progress:0,message:"",logs:[]},activeAnalysesList:[]});return{subscribe:y,update:a,async loadAnalyses(){a(s=>({...s,isLoading:!0,error:null}));try{const s=await d.getAllAnalyses();a(e=>({...e,analyses:s,isLoading:!1}))}catch(s){console.error("Error loading analyses:",s),a(e=>({...e,error:s.message,isLoading:!1}))}},async createAnalysis(s,e){a(r=>({...r,isLoading:!0,error:null}));try{const r=crypto.randomUUID(),n={id:r,fileId:s,method:e,status:"pending",createdAt:new Date().getTime()};return await d.saveAnalysis(n),a(i=>({...i,analyses:[...i.analyses,n],currentAnalysisId:r,isLoading:!1})),r}catch(r){throw console.error("Error creating analysis:",r),a(n=>({...n,error:r.message,isLoading:!1})),r}},async getAnalysis(s){a(e=>({...e,isLoading:!0,error:null}));try{const e=await d.getAnalysis(s);return a(r=>{const n=r.analyses.map(i=>i.id===s?e:i);return{...r,analyses:n,isLoading:!1}}),e}catch(e){throw console.error("Error fetching analysis:",e),a(r=>({...r,error:e.message,isLoading:!1})),e}},async updateAnalysis(s,e){a(r=>({...r,isLoading:!0,error:null}));try{const n={...await d.getAnalysis(s),...e,updatedAt:new Date().getTime()};return await d.saveAnalysis(n),a(i=>{const o=i.analyses.map(t=>t.id===s?n:t);return{...i,analyses:o,isLoading:!1}}),n}catch(r){throw console.error("Error updating analysis:",r),a(n=>({...n,error:r.message,isLoading:!1})),r}},async deleteAnalysis(s){a(e=>({...e,isLoading:!0,error:null}));try{await d.deleteAnalysis(s),a(e=>({...e,analyses:e.analyses.filter(r=>r.id!==s),currentAnalysisId:e.currentAnalysisId===s?null:e.currentAnalysisId,isLoading:!1}))}catch(e){throw console.error("Error deleting analysis:",e),a(r=>({...r,error:e.message,isLoading:!1})),e}},async cancelAnalysis(s){try{await this.updateAnalysis(s,{status:"cancelled",completedAt:new Date().getTime()}),a(e=>{const r={...e};return r.activeAnalysis.id===s&&(r.activeAnalysis={id:null,status:null,progress:0,message:"",logs:[]}),r.activeAnalysesList=r.activeAnalysesList.filter(n=>n.id!==s),r})}catch(e){throw console.error("Error cancelling analysis:",e),e}},async loadAnalysesForFile(s){a(e=>({...e,isLoading:!0,error:null}));try{const e=await d.getAnalysesByFileId(s);return a(r=>{const n=r.analyses.filter(i=>i.fileId!==s);return{...r,analyses:[...n,...e],isLoading:!1}}),e}catch(e){throw console.error("Error loading analyses for file:",e),a(r=>({...r,error:e.message,isLoading:!1})),e}},setCurrentAnalysis(s){a(e=>({...e,currentAnalysisId:s}))},clearError(){a(s=>({...s,error:null}))},startAnalysisProgress(s,e="Initializing analysis...",r="",n=""){let i=r,o=n;a(t=>{if(!i||!o){const A=t.analyses.find(v=>v.id===s);A&&(i=i||A.method,o=o||A.fileName)}const c={id:s,status:"initializing",progress:0,message:e,method:i,fileName:o,startTime:new Date().toISOString(),logs:[{time:new Date().toISOString(),message:e,status:"initializing"}]},l={...c},u=[...t.activeAnalysesList.filter(A=>A.id!==s),c];return{...t,activeAnalysis:l,activeAnalysesList:u}})},updateAnalysisProgress(s,e,r){a(n=>{const i=n.activeAnalysis.id;if(!i)return n;const o=[...n.activeAnalysis.logs],t=o[o.length-1];(!t||t.message!==r||t.status!==s)&&o.push({time:new Date().toISOString(),message:r,status:s});const c={...n.activeAnalysis,status:s,progress:Math.min(Math.max(0,e),100),message:r,logs:o},l=n.activeAnalysesList.map(g=>g.id!==i?g:{...g,status:s,progress:Math.min(Math.max(0,e),100),message:r,logs:[...o]});return{...n,activeAnalysis:c,activeAnalysesList:l}})},async completeAnalysisProgress(s=!0,e=s?"Analysis completed.":"Analysis failed."){var o;const r=s?"completed":"error";let n;y(t=>{n=t})();const i=(o=n==null?void 0:n.activeAnalysis)==null?void 0:o.id;if(i&&(a(t=>{const c=[...t.activeAnalysis.logs];c.push({time:new Date().toISOString(),message:e,status:r});const l={...t.activeAnalysis,status:r,progress:s?100:t.activeAnalysis.progress,message:e,logs:c,completedAt:s?new Date().toISOString():void 0},g=t.activeAnalysesList.map(u=>u.id!==i?u:{...u,status:r,progress:s?100:u.progress,message:e,logs:[...c],completedAt:s?new Date().toISOString():void 0});return{...t,activeAnalysis:l,activeAnalysesList:g}}),i)){const t=n.activeAnalysis.logs||[],c=n.activeAnalysis.result||null;try{const l=await d.getAnalysis(i);if(l){const g=c||l.result;await d.saveAnalysis({...l,status:r,logs:t,result:g,completedAt:s?new Date().getTime():void 0}),a(u=>({...u,analyses:u.analyses.map(A=>A.id===i?{...A,status:r,logs:t,result:g,completedAt:s?new Date().getTime():void 0}:A)}))}}catch(l){console.error("Error updating analysis in IndexedDB:",l)}try{w&&fetch(`/api/analyses/${i}`,{method:"PATCH",headers:{"Content-Type":"application/json"},body:JSON.stringify({status:r,logs:t,result:c,completedAt:s?new Date().getTime():void 0})}).then(l=>l.json()).then(l=>{console.log("Server analysis status updated:",l)}).catch(l=>{console.error("Error updating analysis status on server:",l)})}catch(l){console.error("Error updating analysis on server:",l)}}},removeFromActiveAnalyses(s){a(e=>({...e,activeAnalysesList:e.activeAnalysesList.filter(r=>r.id!==s)}))},async clearAllAnalyses(){a(s=>({...s,isLoading:!0,error:null}));try{await d.clearAllAnalyses(),a(s=>({...s,analyses:[],currentAnalysisId:null,activeAnalysis:{id:null,status:null,progress:0,message:"",logs:[]},activeAnalysesList:[],isLoading:!1}))}catch(s){throw console.error("Error clearing all analyses:",s),a(e=>({...e,error:s.message,isLoading:!1})),s}}}}const p=S();f(p,y=>y.currentAnalysisId?y.analyses.find(m=>m.id===y.currentAnalysisId):null);f(p,y=>y.activeAnalysis);f(p,y=>y.activeAnalysesList);export{p as a};
