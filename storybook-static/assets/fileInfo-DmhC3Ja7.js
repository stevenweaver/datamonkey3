import{d as h,w as m}from"./index-BJUjmB_L.js";const A="fasta-validation-db",E=1,d="files",u="analyses";async function y(){return new Promise((n,t)=>{const o=indexedDB.open(A,E);o.onerror=e=>{console.error("IndexedDB error:",e.target.error),t(e.target.error)},o.onsuccess=e=>{const r=e.target.result;n(r)},o.onupgradeneeded=e=>{const r=e.target.result;if(!r.objectStoreNames.contains(d)){const s=r.createObjectStore(d,{keyPath:"id"});s.createIndex("filename","filename",{unique:!1}),s.createIndex("createdAt","createdAt",{unique:!1})}if(!r.objectStoreNames.contains(u)){const s=r.createObjectStore(u,{keyPath:"id"});s.createIndex("fileId","fileId",{unique:!1}),s.createIndex("method","method",{unique:!1}),s.createIndex("createdAt","createdAt",{unique:!1})}}})}const w={async saveFile(n,t={}){try{const o=await y(),e=await this.findFileByName(n.name);if(e&&!t.forceNew)return this.updateFile(e.id,{...e,type:n.type,size:n.size,content:await n.arrayBuffer(),updatedAt:new Date().getTime(),...t});const r=crypto.randomUUID(),s=await n.arrayBuffer();return new Promise((a,i)=>{const l=o.transaction([d],"readwrite").objectStore(d),g={id:r,filename:n.name,type:n.type,size:n.size,content:s,createdAt:new Date().getTime(),...t},f=l.add(g);f.onsuccess=()=>{a(r)},f.onerror=F=>{console.error("Error saving file:",F.target.error),i(F.target.error)}})}catch(o){throw console.error("Error in saveFile:",o),o}},async getFile(n){try{const t=await y();return new Promise((o,e)=>{const a=t.transaction([d],"readonly").objectStore(d).get(n);a.onsuccess=i=>{i.target.result?o(i.target.result):e(new Error("File not found"))},a.onerror=i=>{console.error("Error retrieving file:",i.target.error),e(i.target.error)}})}catch(t){throw console.error("Error in getFile:",t),t}},async getAllFiles(){try{const n=await y();return new Promise((t,o)=>{const s=n.transaction([d],"readonly").objectStore(d).getAll();s.onsuccess=a=>{const i=a.target.result.map(c=>{const{content:l,...g}=c;return g});t(i)},s.onerror=a=>{console.error("Error retrieving files:",a.target.error),o(a.target.error)}})}catch(n){throw console.error("Error in getAllFiles:",n),n}},async deleteFile(n){try{const t=await y();return new Promise((o,e)=>{const a=t.transaction([d],"readwrite").objectStore(d).delete(n);a.onsuccess=()=>{o(!0)},a.onerror=i=>{console.error("Error deleting file:",i.target.error),e(i.target.error)}})}catch(t){throw console.error("Error in deleteFile:",t),t}},async updateFile(n,t){try{const o=await y();return new Promise((e,r)=>{const i=o.transaction([d],"readwrite").objectStore(d).put(t);i.onsuccess=()=>{e(!0)},i.onerror=c=>{console.error("Error updating file:",c.target.error),r(c.target.error)}})}catch(o){throw console.error("Error in updateFile:",o),o}},async findFileByName(n){try{const t=await y();return new Promise((o,e)=>{const i=t.transaction([d],"readonly").objectStore(d).index("filename").getAll(n);i.onsuccess=c=>{const l=c.target.result;if(l&&l.length>0){const g=l.sort((f,F)=>F.createdAt-f.createdAt);o(g[0])}else o(null)},i.onerror=c=>{console.error("Error finding file by name:",c.target.error),e(c.target.error)}})}catch(t){throw console.error("Error in findFileByName:",t),t}},async fileRecordToFile(n){try{const{content:t,filename:o,type:e}=n;return new File([t],o,{type:e})}catch(t){throw console.error("Error converting file record:",t),t}}},I={async saveAnalysis(n){try{const t=await y(),o=n.id||crypto.randomUUID();return new Promise((e,r)=>{const a=t.transaction([u],"readwrite").objectStore(u),i={...n,id:o,createdAt:n.createdAt||new Date().getTime(),updatedAt:new Date().getTime()},c=a.put(i);c.onsuccess=()=>{e(o)},c.onerror=l=>{console.error("Error saving analysis:",l.target.error),r(l.target.error)}})}catch(t){throw console.error("Error in saveAnalysis:",t),t}},async getAnalysis(n){try{const t=await y();return new Promise((o,e)=>{const a=t.transaction([u],"readonly").objectStore(u).get(n);a.onsuccess=i=>{i.target.result?o(i.target.result):e(new Error("Analysis not found"))},a.onerror=i=>{console.error("Error retrieving analysis:",i.target.error),e(i.target.error)}})}catch(t){throw console.error("Error in getAnalysis:",t),t}},async getAllAnalyses(){try{const n=await y();return new Promise((t,o)=>{const s=n.transaction([u],"readonly").objectStore(u).getAll();s.onsuccess=a=>{t(a.target.result)},s.onerror=a=>{console.error("Error retrieving analyses:",a.target.error),o(a.target.error)}})}catch(n){throw console.error("Error in getAllAnalyses:",n),n}},async getAnalysesByFileId(n){try{const t=await y();return new Promise((o,e)=>{const i=t.transaction([u],"readonly").objectStore(u).index("fileId").getAll(n);i.onsuccess=c=>{o(c.target.result)},i.onerror=c=>{console.error("Error retrieving analyses for file:",c.target.error),e(c.target.error)}})}catch(t){throw console.error("Error in getAnalysesByFileId:",t),t}},async deleteAnalysis(n){try{const t=await y();return new Promise((o,e)=>{const a=t.transaction([u],"readwrite").objectStore(u).delete(n);a.onsuccess=()=>{o(!0)},a.onerror=i=>{console.error("Error deleting analysis:",i.target.error),e(i.target.error)}})}catch(t){throw console.error("Error in deleteAnalysis:",t),t}},async clearAllAnalyses(){try{const n=await y();return new Promise((t,o)=>{const s=n.transaction([u],"readwrite").objectStore(u).clear();s.onsuccess=()=>{t(!0)},s.onerror=a=>{console.error("Error clearing all analyses:",a.target.error),o(a.target.error)}})}catch(n){throw console.error("Error in clearAllAnalyses:",n),n}}},x=m(null);function b(){const{subscribe:n,set:t,update:o}=m({files:[],currentFileId:null,isLoading:!1,error:null});return{subscribe:n,async loadFiles(){o(e=>({...e,isLoading:!0,error:null}));try{const e=await w.getAllFiles();o(r=>({...r,files:e,isLoading:!1}))}catch(e){console.error("Error loading files:",e),o(r=>({...r,error:e.message,isLoading:!1}))}},async uploadFile(e){o(r=>({...r,isLoading:!0,error:null}));try{let r=null;o(l=>{const g=l.files.find(f=>f.filename===e.name);return g&&(r=g.id),l});let s;if(r){console.log(`File with name ${e.name} already exists. Updating content.`);const l=await w.getFile(r),g=await e.arrayBuffer(),f={...l,content:g,size:e.size,type:e.type,updatedAt:new Date().getTime()};await w.updateFile(r,f),s=r}else s=await w.saveFile(e);const a=await w.getFile(s),{content:i,...c}=a;return o(l=>r?{...l,files:l.files.map(g=>g.id===s?c:g),currentFileId:s,isLoading:!1}:{...l,files:[...l.files,c],currentFileId:s,isLoading:!1}),s}catch(r){throw console.error("Error uploading file:",r),o(s=>({...s,error:r.message,isLoading:!1})),r}},async getFile(e){o(r=>({...r,isLoading:!0,error:null}));try{const r=await w.getFile(e),s=await w.fileRecordToFile(r);return o(a=>({...a,isLoading:!1})),s}catch(r){throw console.error("Error getting file:",r),o(s=>({...s,error:r.message,isLoading:!1})),r}},async deleteFile(e){o(r=>({...r,isLoading:!0,error:null}));try{await w.deleteFile(e),o(r=>({...r,files:r.files.filter(s=>s.id!==e),currentFileId:r.currentFileId===e?null:r.currentFileId,isLoading:!1}))}catch(r){throw console.error("Error deleting file:",r),o(s=>({...s,error:r.message,isLoading:!1})),r}},setCurrentFile(e){o(r=>({...r,currentFileId:e}))},clearError(){o(e=>({...e,error:null}))}}}const p=b(),q=h(p,n=>n.currentFileId?n.files.find(t=>t.id===n.currentFileId):null);export{I as a,q as c,x as f,p};
